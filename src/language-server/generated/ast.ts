/******************************************************************************
 * This file was generated by langium-cli 0.5.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable @typescript-eslint/array-type */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { AstNode, AstReflection, Reference, ReferenceInfo, isAstNode, TypeMetaData } from 'langium';

export type Element = Class | Enum | Import;

export const Element = 'Element';

export function isElement(item: unknown): item is Element {
    return reflection.isInstance(item, Element);
}

export type TypeOutputDefinition = TypeDefinition;

export const TypeOutputDefinition = 'TypeOutputDefinition';

export function isTypeOutputDefinition(item: unknown): item is TypeOutputDefinition {
    return reflection.isInstance(item, TypeOutputDefinition);
}

export interface AbstractClass extends AstNode {
    readonly $container: Model;
    functions: Array<Function>
    name: string
}

export const AbstractClass = 'AbstractClass';

export function isAbstractClass(item: unknown): item is AbstractClass {
    return reflection.isInstance(item, AbstractClass);
}

export interface Attribute extends AstNode {
    readonly $container: Class;
    name: string
    typeDefinition?: Reference<Element> | TypeDefinition
    visibility: Visibility
}

export const Attribute = 'Attribute';

export function isAttribute(item: unknown): item is Attribute {
    return reflection.isInstance(item, Attribute);
}

export interface Class extends AstNode {
    readonly $container: Model;
    attributes: Array<Attribute>
    extension?: Extension
    functions: Array<Function>
    implementation?: Implementation
    name: string
}

export const Class = 'Class';

export function isClass(item: unknown): item is Class {
    return reflection.isInstance(item, Class);
}

export interface Enum extends AstNode {
    readonly $container: Model;
    enumItems: Array<EnumItem>
    name: string
}

export const Enum = 'Enum';

export function isEnum(item: unknown): item is Enum {
    return reflection.isInstance(item, Enum);
}

export interface EnumItem extends AstNode {
    readonly $container: Enum;
    name: string
}

export const EnumItem = 'EnumItem';

export function isEnumItem(item: unknown): item is EnumItem {
    return reflection.isInstance(item, EnumItem);
}

export interface Extension extends AstNode {
    readonly $container: Class;
    class: Reference<Class>
}

export const Extension = 'Extension';

export function isExtension(item: unknown): item is Extension {
    return reflection.isInstance(item, Extension);
}

export interface Function extends AstNode {
    readonly $container: AbstractClass | Class;
    inputs?: Inputs
    name: string
    typeOutputDefition?: Reference<Element> | TypeOutputDefinition
    visibility: Visibility
}

export const Function = 'Function';

export function isFunction(item: unknown): item is Function {
    return reflection.isInstance(item, Function);
}

export interface Implementation extends AstNode {
    readonly $container: Class;
    abstractClass: Reference<AbstractClass>
}

export const Implementation = 'Implementation';

export function isImplementation(item: unknown): item is Implementation {
    return reflection.isInstance(item, Implementation);
}

export interface Import extends AstNode {
    readonly $container: Model;
    name: string
}

export const Import = 'Import';

export function isImport(item: unknown): item is Import {
    return reflection.isInstance(item, Import);
}

export interface Input extends AstNode {
    readonly $container: Inputs;
    name: string
    typeDefinition?: Reference<Element> | TypeDefinition
}

export const Input = 'Input';

export function isInput(item: unknown): item is Input {
    return reflection.isInstance(item, Input);
}

export interface Inputs extends AstNode {
    readonly $container: Function;
    inputs: Array<Input>
}

export const Inputs = 'Inputs';

export function isInputs(item: unknown): item is Inputs {
    return reflection.isInstance(item, Inputs);
}

export interface Model extends AstNode {
    abstractClasses: Array<AbstractClass>
    classes: Array<Class>
    enums: Array<Enum>
    imports: Array<Import>
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface TypeDefinition extends AstNode {
    readonly $container: Attribute | Function | Input;
    data: 'DateTime' | 'int' | 'string'
}

export const TypeDefinition = 'TypeDefinition';

export function isTypeDefinition(item: unknown): item is TypeDefinition {
    return reflection.isInstance(item, TypeDefinition);
}

export interface Visibility extends AstNode {
    readonly $container: Attribute | Function;
    visibility: '#' | '+' | '-'
}

export const Visibility = 'Visibility';

export function isVisibility(item: unknown): item is Visibility {
    return reflection.isInstance(item, Visibility);
}

export type ClassLanguageAstType = 'AbstractClass' | 'Attribute' | 'Class' | 'Element' | 'Enum' | 'EnumItem' | 'Extension' | 'Function' | 'Implementation' | 'Import' | 'Input' | 'Inputs' | 'Model' | 'TypeDefinition' | 'TypeOutputDefinition' | 'Visibility';

export class ClassLanguageAstReflection implements AstReflection {

    getAllTypes(): string[] {
        return ['AbstractClass', 'Attribute', 'Class', 'Element', 'Enum', 'EnumItem', 'Extension', 'Function', 'Implementation', 'Import', 'Input', 'Inputs', 'Model', 'TypeDefinition', 'TypeOutputDefinition', 'Visibility'];
    }

    isInstance(node: unknown, type: string): boolean {
        return isAstNode(node) && this.isSubtype(node.$type, type);
    }

    isSubtype(subtype: string, supertype: string): boolean {
        if (subtype === supertype) {
            return true;
        }
        switch (subtype) {
            case Class:
            case Enum:
            case Import: {
                return this.isSubtype(Element, supertype);
            }
            case TypeDefinition: {
                return this.isSubtype(TypeOutputDefinition, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Attribute:typeDefinition': {
                return Element;
            }
            case 'Extension:class': {
                return Class;
            }
            case 'Function:typeOutputDefition': {
                return Element;
            }
            case 'Implementation:abstractClass': {
                return AbstractClass;
            }
            case 'Input:typeDefinition': {
                return Element;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'AbstractClass': {
                return {
                    name: 'AbstractClass',
                    mandatory: [
                        { name: 'functions', type: 'array' }
                    ]
                };
            }
            case 'Class': {
                return {
                    name: 'Class',
                    mandatory: [
                        { name: 'attributes', type: 'array' },
                        { name: 'functions', type: 'array' }
                    ]
                };
            }
            case 'Enum': {
                return {
                    name: 'Enum',
                    mandatory: [
                        { name: 'enumItems', type: 'array' }
                    ]
                };
            }
            case 'Inputs': {
                return {
                    name: 'Inputs',
                    mandatory: [
                        { name: 'inputs', type: 'array' }
                    ]
                };
            }
            case 'Model': {
                return {
                    name: 'Model',
                    mandatory: [
                        { name: 'abstractClasses', type: 'array' },
                        { name: 'classes', type: 'array' },
                        { name: 'enums', type: 'array' },
                        { name: 'imports', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new ClassLanguageAstReflection();
